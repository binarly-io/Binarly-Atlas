// Code generated by protoc-gen-go. DO NOT EDIT.
// source: service_control_plane.proto

package atlas

import (
	context "context"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

func init() { proto.RegisterFile("service_control_plane.proto", fileDescriptor_144c4e5d826a1f85) }

var fileDescriptor_144c4e5d826a1f85 = []byte{
	// 232 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x64, 0x8f, 0xcf, 0x4a, 0xc4, 0x30,
	0x10, 0xc6, 0xb7, 0x07, 0xff, 0x30, 0xa8, 0xe8, 0xa0, 0x88, 0xf1, 0xb6, 0x27, 0x41, 0x28, 0x8b,
	0x82, 0x78, 0xaf, 0x78, 0x13, 0x44, 0x1f, 0xa0, 0x8c, 0xdd, 0x80, 0xc5, 0xb4, 0x89, 0x99, 0xa9,
	0xd0, 0xa7, 0xf5, 0x55, 0x24, 0xc9, 0x20, 0xec, 0xee, 0xf1, 0xfb, 0x7d, 0x5f, 0xc8, 0x6f, 0xe0,
	0x9a, 0x6d, 0xfc, 0xe9, 0x3b, 0xdb, 0x76, 0x7e, 0x94, 0xe8, 0x5d, 0x1b, 0x1c, 0x8d, 0xb6, 0x0e,
	0xd1, 0x8b, 0xc7, 0x3d, 0x12, 0x47, 0x6c, 0x50, 0xe6, 0x90, 0x06, 0xc3, 0x40, 0xe3, 0xba, 0x54,
	0xe6, 0x22, 0xb3, 0x35, 0x09, 0xb5, 0xdd, 0xe7, 0x34, 0x7e, 0x29, 0x3e, 0xcb, 0x78, 0xb0, 0x12,
	0xfb, 0x4e, 0xd1, 0x55, 0x46, 0x2c, 0x24, 0x13, 0xb7, 0xd1, 0x7e, 0x4f, 0x96, 0x45, 0xab, 0xcb,
	0xcd, 0x2a, 0xb8, 0xb9, 0x14, 0x77, 0xbf, 0x15, 0x1c, 0x35, 0x45, 0xe8, 0x35, 0xf9, 0xe0, 0x0a,
	0x0e, 0x9b, 0xf2, 0x3f, 0xe3, 0x49, 0x9d, 0xb5, 0x6a, 0x05, 0x66, 0x2b, 0x2f, 0x17, 0x37, 0xd5,
	0xaa, 0xc2, 0x07, 0x80, 0x27, 0x12, 0x6a, 0x92, 0x1c, 0xe3, 0xa9, 0x6e, 0xfe, 0x91, 0xd9, 0x21,
	0xfa, 0xee, 0x16, 0x0e, 0x5e, 0xb2, 0x3e, 0xe3, 0xb1, 0x4e, 0x4a, 0x36, 0x9b, 0x31, 0xcd, 0xf1,
	0x11, 0xe0, 0xb9, 0x77, 0xf6, 0x3d, 0x5f, 0x80, 0xe7, 0x3a, 0x28, 0xf1, 0xad, 0x9c, 0x6a, 0x70,
	0x8b, 0x06, 0x37, 0x2f, 0x17, 0x1f, 0xfb, 0xf9, 0xd0, 0xfb, 0xbf, 0x00, 0x00, 0x00, 0xff, 0xff,
	0x92, 0xd0, 0xaa, 0xfd, 0x80, 0x01, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// ControlPlaneClient is the client API for ControlPlane service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type ControlPlaneClient interface {
	// Bi-directional Commands stream
	//
	// Commands are sent from service to client and from client to server
	Commands(ctx context.Context, opts ...grpc.CallOption) (ControlPlane_CommandsClient, error)
	// Bi-directional Data stream
	//
	// Some commands may be followed by data load. Be it logs, dumps, etc.
	DataChunks(ctx context.Context, opts ...grpc.CallOption) (ControlPlane_DataChunksClient, error)
	// Metrics stream
	//
	// Some commands may be followed by metrics stream.
	Metrics(ctx context.Context, opts ...grpc.CallOption) (ControlPlane_MetricsClient, error)
	// FileStatus checks status of the file on server
	FileStatus(ctx context.Context, in *StatusRequest, opts ...grpc.CallOption) (*StatusReply, error)
}

type controlPlaneClient struct {
	cc *grpc.ClientConn
}

func NewControlPlaneClient(cc *grpc.ClientConn) ControlPlaneClient {
	return &controlPlaneClient{cc}
}

func (c *controlPlaneClient) Commands(ctx context.Context, opts ...grpc.CallOption) (ControlPlane_CommandsClient, error) {
	stream, err := c.cc.NewStream(ctx, &_ControlPlane_serviceDesc.Streams[0], "/atlas.ControlPlane/Commands", opts...)
	if err != nil {
		return nil, err
	}
	x := &controlPlaneCommandsClient{stream}
	return x, nil
}

type ControlPlane_CommandsClient interface {
	Send(*Command) error
	Recv() (*Command, error)
	grpc.ClientStream
}

type controlPlaneCommandsClient struct {
	grpc.ClientStream
}

func (x *controlPlaneCommandsClient) Send(m *Command) error {
	return x.ClientStream.SendMsg(m)
}

func (x *controlPlaneCommandsClient) Recv() (*Command, error) {
	m := new(Command)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *controlPlaneClient) DataChunks(ctx context.Context, opts ...grpc.CallOption) (ControlPlane_DataChunksClient, error) {
	stream, err := c.cc.NewStream(ctx, &_ControlPlane_serviceDesc.Streams[1], "/atlas.ControlPlane/DataChunks", opts...)
	if err != nil {
		return nil, err
	}
	x := &controlPlaneDataChunksClient{stream}
	return x, nil
}

type ControlPlane_DataChunksClient interface {
	Send(*DataChunk) error
	Recv() (*DataChunk, error)
	grpc.ClientStream
}

type controlPlaneDataChunksClient struct {
	grpc.ClientStream
}

func (x *controlPlaneDataChunksClient) Send(m *DataChunk) error {
	return x.ClientStream.SendMsg(m)
}

func (x *controlPlaneDataChunksClient) Recv() (*DataChunk, error) {
	m := new(DataChunk)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *controlPlaneClient) Metrics(ctx context.Context, opts ...grpc.CallOption) (ControlPlane_MetricsClient, error) {
	stream, err := c.cc.NewStream(ctx, &_ControlPlane_serviceDesc.Streams[2], "/atlas.ControlPlane/Metrics", opts...)
	if err != nil {
		return nil, err
	}
	x := &controlPlaneMetricsClient{stream}
	return x, nil
}

type ControlPlane_MetricsClient interface {
	Send(*Metric) error
	CloseAndRecv() (*Metric, error)
	grpc.ClientStream
}

type controlPlaneMetricsClient struct {
	grpc.ClientStream
}

func (x *controlPlaneMetricsClient) Send(m *Metric) error {
	return x.ClientStream.SendMsg(m)
}

func (x *controlPlaneMetricsClient) CloseAndRecv() (*Metric, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(Metric)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *controlPlaneClient) FileStatus(ctx context.Context, in *StatusRequest, opts ...grpc.CallOption) (*StatusReply, error) {
	out := new(StatusReply)
	err := c.cc.Invoke(ctx, "/atlas.ControlPlane/FileStatus", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ControlPlaneServer is the server API for ControlPlane service.
type ControlPlaneServer interface {
	// Bi-directional Commands stream
	//
	// Commands are sent from service to client and from client to server
	Commands(ControlPlane_CommandsServer) error
	// Bi-directional Data stream
	//
	// Some commands may be followed by data load. Be it logs, dumps, etc.
	DataChunks(ControlPlane_DataChunksServer) error
	// Metrics stream
	//
	// Some commands may be followed by metrics stream.
	Metrics(ControlPlane_MetricsServer) error
	// FileStatus checks status of the file on server
	FileStatus(context.Context, *StatusRequest) (*StatusReply, error)
}

// UnimplementedControlPlaneServer can be embedded to have forward compatible implementations.
type UnimplementedControlPlaneServer struct {
}

func (*UnimplementedControlPlaneServer) Commands(srv ControlPlane_CommandsServer) error {
	return status.Errorf(codes.Unimplemented, "method Commands not implemented")
}
func (*UnimplementedControlPlaneServer) DataChunks(srv ControlPlane_DataChunksServer) error {
	return status.Errorf(codes.Unimplemented, "method DataChunks not implemented")
}
func (*UnimplementedControlPlaneServer) Metrics(srv ControlPlane_MetricsServer) error {
	return status.Errorf(codes.Unimplemented, "method Metrics not implemented")
}
func (*UnimplementedControlPlaneServer) FileStatus(ctx context.Context, req *StatusRequest) (*StatusReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FileStatus not implemented")
}

func RegisterControlPlaneServer(s *grpc.Server, srv ControlPlaneServer) {
	s.RegisterService(&_ControlPlane_serviceDesc, srv)
}

func _ControlPlane_Commands_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(ControlPlaneServer).Commands(&controlPlaneCommandsServer{stream})
}

type ControlPlane_CommandsServer interface {
	Send(*Command) error
	Recv() (*Command, error)
	grpc.ServerStream
}

type controlPlaneCommandsServer struct {
	grpc.ServerStream
}

func (x *controlPlaneCommandsServer) Send(m *Command) error {
	return x.ServerStream.SendMsg(m)
}

func (x *controlPlaneCommandsServer) Recv() (*Command, error) {
	m := new(Command)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _ControlPlane_DataChunks_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(ControlPlaneServer).DataChunks(&controlPlaneDataChunksServer{stream})
}

type ControlPlane_DataChunksServer interface {
	Send(*DataChunk) error
	Recv() (*DataChunk, error)
	grpc.ServerStream
}

type controlPlaneDataChunksServer struct {
	grpc.ServerStream
}

func (x *controlPlaneDataChunksServer) Send(m *DataChunk) error {
	return x.ServerStream.SendMsg(m)
}

func (x *controlPlaneDataChunksServer) Recv() (*DataChunk, error) {
	m := new(DataChunk)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _ControlPlane_Metrics_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(ControlPlaneServer).Metrics(&controlPlaneMetricsServer{stream})
}

type ControlPlane_MetricsServer interface {
	SendAndClose(*Metric) error
	Recv() (*Metric, error)
	grpc.ServerStream
}

type controlPlaneMetricsServer struct {
	grpc.ServerStream
}

func (x *controlPlaneMetricsServer) SendAndClose(m *Metric) error {
	return x.ServerStream.SendMsg(m)
}

func (x *controlPlaneMetricsServer) Recv() (*Metric, error) {
	m := new(Metric)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _ControlPlane_FileStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ControlPlaneServer).FileStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/atlas.ControlPlane/FileStatus",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ControlPlaneServer).FileStatus(ctx, req.(*StatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _ControlPlane_serviceDesc = grpc.ServiceDesc{
	ServiceName: "atlas.ControlPlane",
	HandlerType: (*ControlPlaneServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "FileStatus",
			Handler:    _ControlPlane_FileStatus_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Commands",
			Handler:       _ControlPlane_Commands_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "DataChunks",
			Handler:       _ControlPlane_DataChunks_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "Metrics",
			Handler:       _ControlPlane_Metrics_Handler,
			ClientStreams: true,
		},
	},
	Metadata: "service_control_plane.proto",
}
