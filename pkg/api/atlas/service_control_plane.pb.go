// Code generated by protoc-gen-go. DO NOT EDIT.
// source: service_control_plane.proto

package atlas

import (
	context "context"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

func init() { proto.RegisterFile("service_control_plane.proto", fileDescriptor_144c4e5d826a1f85) }

var fileDescriptor_144c4e5d826a1f85 = []byte{
	// 273 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x6c, 0x91, 0x4f, 0x4b, 0xc3, 0x40,
	0x10, 0xc5, 0x2d, 0xe2, 0x1f, 0x86, 0x44, 0xca, 0xd0, 0x8b, 0xeb, 0xcd, 0x93, 0x20, 0x94, 0x62,
	0x51, 0xf0, 0x26, 0xc4, 0x6b, 0x51, 0x14, 0xcf, 0x61, 0xba, 0x59, 0x30, 0x9a, 0x64, 0xe3, 0xee,
	0xc4, 0x8f, 0xe1, 0x67, 0x96, 0xec, 0x4e, 0x25, 0xb1, 0x39, 0xbe, 0x97, 0xf7, 0xdb, 0xfc, 0xb2,
	0x81, 0x0b, 0x6f, 0xdc, 0x77, 0xa9, 0x4d, 0xae, 0x6d, 0xc3, 0xce, 0x56, 0x79, 0x5b, 0x51, 0x63,
	0x96, 0xad, 0xb3, 0x6c, 0xf1, 0x88, 0xb8, 0x22, 0xaf, 0x52, 0x6d, 0xeb, 0x9a, 0x9a, 0x22, 0xb6,
	0x6a, 0x5e, 0x10, 0x53, 0xae, 0xdf, 0xbb, 0xe6, 0x53, 0x9a, 0xa4, 0x36, 0xec, 0x4a, 0x2d, 0x69,
	0xe1, 0x99, 0xb8, 0xf3, 0xb9, 0x33, 0x5f, 0x9d, 0xf1, 0x2c, 0xad, 0x1a, 0xb7, 0x79, 0xdd, 0x55,
	0x5c, 0xee, 0xf8, 0xf8, 0x4c, 0x12, 0xca, 0x72, 0xb0, 0xb8, 0xf9, 0x39, 0x84, 0x24, 0x8b, 0x86,
	0xcf, 0xbd, 0x20, 0xae, 0xe0, 0x34, 0x8b, 0x56, 0x1e, 0xcf, 0x96, 0xc1, 0x73, 0x29, 0x85, 0xfa,
	0x97, 0x2f, 0x0f, 0xae, 0x66, 0xab, 0x19, 0xde, 0x01, 0x3c, 0x12, 0x53, 0xd6, 0x7b, 0x7b, 0x9c,
	0xcb, 0xe6, 0xaf, 0x52, 0x7b, 0x8d, 0x70, 0x6b, 0x48, 0xde, 0xda, 0xca, 0x52, 0xf1, 0xb4, 0xfd,
	0x30, 0x9a, 0x27, 0xc8, 0x54, 0x9a, 0xd7, 0xe0, 0xdd, 0x63, 0x78, 0x0f, 0xe9, 0x10, 0x9a, 0x7a,
	0x1f, 0x8e, 0xa8, 0x4d, 0xff, 0xb1, 0x01, 0xbd, 0x86, 0x93, 0x4d, 0xb8, 0x4e, 0x8f, 0xbb, 0x83,
	0x63, 0x56, 0xe3, 0x18, 0xc6, 0xb7, 0x90, 0x44, 0x5e, 0xe4, 0x16, 0xa3, 0x43, 0x5f, 0xe2, 0x5d,
	0xef, 0x09, 0xe2, 0x03, 0xa4, 0x43, 0xcc, 0xe3, 0xf9, 0x14, 0x17, 0x9c, 0xa6, 0x3d, 0xb7, 0xc7,
	0xe1, 0xbf, 0xac, 0x7f, 0x03, 0x00, 0x00, 0xff, 0xff, 0x7b, 0xe0, 0x13, 0xac, 0x40, 0x02, 0x00,
	0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// ControlPlaneClient is the client API for ControlPlane service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type ControlPlaneClient interface {
	//*
	// Bi-directional Commands stream.
	// Commands are sent from service to client and from client to server
	Commands(ctx context.Context, opts ...grpc.CallOption) (ControlPlane_CommandsClient, error)
	//*
	// Bi-directional Data stream.
	// Some commands may be followed by data load. Be it logs, dumps, etc.
	DataChunks(ctx context.Context, opts ...grpc.CallOption) (ControlPlane_DataChunksClient, error)
	UploadObject(ctx context.Context, opts ...grpc.CallOption) (ControlPlane_UploadObjectClient, error)
	UploadObjects(ctx context.Context, opts ...grpc.CallOption) (ControlPlane_UploadObjectsClient, error)
	//*
	// Uni-directional Metrics stream from client to server.
	Metrics(ctx context.Context, opts ...grpc.CallOption) (ControlPlane_MetricsClient, error)
	//*
	// ObjectStatus checks status of the object on the server.
	StatusObject(ctx context.Context, in *StatusRequest, opts ...grpc.CallOption) (*Status, error)
	//*
	// ObjectStatusMulti checks status of the multiple objects on server.
	StatusObjects(ctx context.Context, in *StatusRequestMulti, opts ...grpc.CallOption) (*StatusMulti, error)
}

type controlPlaneClient struct {
	cc *grpc.ClientConn
}

func NewControlPlaneClient(cc *grpc.ClientConn) ControlPlaneClient {
	return &controlPlaneClient{cc}
}

func (c *controlPlaneClient) Commands(ctx context.Context, opts ...grpc.CallOption) (ControlPlane_CommandsClient, error) {
	stream, err := c.cc.NewStream(ctx, &_ControlPlane_serviceDesc.Streams[0], "/atlas.ControlPlane/Commands", opts...)
	if err != nil {
		return nil, err
	}
	x := &controlPlaneCommandsClient{stream}
	return x, nil
}

type ControlPlane_CommandsClient interface {
	Send(*Command) error
	Recv() (*Command, error)
	grpc.ClientStream
}

type controlPlaneCommandsClient struct {
	grpc.ClientStream
}

func (x *controlPlaneCommandsClient) Send(m *Command) error {
	return x.ClientStream.SendMsg(m)
}

func (x *controlPlaneCommandsClient) Recv() (*Command, error) {
	m := new(Command)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *controlPlaneClient) DataChunks(ctx context.Context, opts ...grpc.CallOption) (ControlPlane_DataChunksClient, error) {
	stream, err := c.cc.NewStream(ctx, &_ControlPlane_serviceDesc.Streams[1], "/atlas.ControlPlane/DataChunks", opts...)
	if err != nil {
		return nil, err
	}
	x := &controlPlaneDataChunksClient{stream}
	return x, nil
}

type ControlPlane_DataChunksClient interface {
	Send(*DataChunk) error
	Recv() (*DataChunk, error)
	grpc.ClientStream
}

type controlPlaneDataChunksClient struct {
	grpc.ClientStream
}

func (x *controlPlaneDataChunksClient) Send(m *DataChunk) error {
	return x.ClientStream.SendMsg(m)
}

func (x *controlPlaneDataChunksClient) Recv() (*DataChunk, error) {
	m := new(DataChunk)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *controlPlaneClient) UploadObject(ctx context.Context, opts ...grpc.CallOption) (ControlPlane_UploadObjectClient, error) {
	stream, err := c.cc.NewStream(ctx, &_ControlPlane_serviceDesc.Streams[2], "/atlas.ControlPlane/UploadObject", opts...)
	if err != nil {
		return nil, err
	}
	x := &controlPlaneUploadObjectClient{stream}
	return x, nil
}

type ControlPlane_UploadObjectClient interface {
	Send(*DataChunk) error
	CloseAndRecv() (*Status, error)
	grpc.ClientStream
}

type controlPlaneUploadObjectClient struct {
	grpc.ClientStream
}

func (x *controlPlaneUploadObjectClient) Send(m *DataChunk) error {
	return x.ClientStream.SendMsg(m)
}

func (x *controlPlaneUploadObjectClient) CloseAndRecv() (*Status, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(Status)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *controlPlaneClient) UploadObjects(ctx context.Context, opts ...grpc.CallOption) (ControlPlane_UploadObjectsClient, error) {
	stream, err := c.cc.NewStream(ctx, &_ControlPlane_serviceDesc.Streams[3], "/atlas.ControlPlane/UploadObjects", opts...)
	if err != nil {
		return nil, err
	}
	x := &controlPlaneUploadObjectsClient{stream}
	return x, nil
}

type ControlPlane_UploadObjectsClient interface {
	Send(*DataChunk) error
	CloseAndRecv() (*StatusMulti, error)
	grpc.ClientStream
}

type controlPlaneUploadObjectsClient struct {
	grpc.ClientStream
}

func (x *controlPlaneUploadObjectsClient) Send(m *DataChunk) error {
	return x.ClientStream.SendMsg(m)
}

func (x *controlPlaneUploadObjectsClient) CloseAndRecv() (*StatusMulti, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(StatusMulti)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *controlPlaneClient) Metrics(ctx context.Context, opts ...grpc.CallOption) (ControlPlane_MetricsClient, error) {
	stream, err := c.cc.NewStream(ctx, &_ControlPlane_serviceDesc.Streams[4], "/atlas.ControlPlane/Metrics", opts...)
	if err != nil {
		return nil, err
	}
	x := &controlPlaneMetricsClient{stream}
	return x, nil
}

type ControlPlane_MetricsClient interface {
	Send(*Metric) error
	CloseAndRecv() (*Metric, error)
	grpc.ClientStream
}

type controlPlaneMetricsClient struct {
	grpc.ClientStream
}

func (x *controlPlaneMetricsClient) Send(m *Metric) error {
	return x.ClientStream.SendMsg(m)
}

func (x *controlPlaneMetricsClient) CloseAndRecv() (*Metric, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(Metric)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *controlPlaneClient) StatusObject(ctx context.Context, in *StatusRequest, opts ...grpc.CallOption) (*Status, error) {
	out := new(Status)
	err := c.cc.Invoke(ctx, "/atlas.ControlPlane/StatusObject", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *controlPlaneClient) StatusObjects(ctx context.Context, in *StatusRequestMulti, opts ...grpc.CallOption) (*StatusMulti, error) {
	out := new(StatusMulti)
	err := c.cc.Invoke(ctx, "/atlas.ControlPlane/StatusObjects", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ControlPlaneServer is the server API for ControlPlane service.
type ControlPlaneServer interface {
	//*
	// Bi-directional Commands stream.
	// Commands are sent from service to client and from client to server
	Commands(ControlPlane_CommandsServer) error
	//*
	// Bi-directional Data stream.
	// Some commands may be followed by data load. Be it logs, dumps, etc.
	DataChunks(ControlPlane_DataChunksServer) error
	UploadObject(ControlPlane_UploadObjectServer) error
	UploadObjects(ControlPlane_UploadObjectsServer) error
	//*
	// Uni-directional Metrics stream from client to server.
	Metrics(ControlPlane_MetricsServer) error
	//*
	// ObjectStatus checks status of the object on the server.
	StatusObject(context.Context, *StatusRequest) (*Status, error)
	//*
	// ObjectStatusMulti checks status of the multiple objects on server.
	StatusObjects(context.Context, *StatusRequestMulti) (*StatusMulti, error)
}

// UnimplementedControlPlaneServer can be embedded to have forward compatible implementations.
type UnimplementedControlPlaneServer struct {
}

func (*UnimplementedControlPlaneServer) Commands(srv ControlPlane_CommandsServer) error {
	return status.Errorf(codes.Unimplemented, "method Commands not implemented")
}
func (*UnimplementedControlPlaneServer) DataChunks(srv ControlPlane_DataChunksServer) error {
	return status.Errorf(codes.Unimplemented, "method DataChunks not implemented")
}
func (*UnimplementedControlPlaneServer) UploadObject(srv ControlPlane_UploadObjectServer) error {
	return status.Errorf(codes.Unimplemented, "method UploadObject not implemented")
}
func (*UnimplementedControlPlaneServer) UploadObjects(srv ControlPlane_UploadObjectsServer) error {
	return status.Errorf(codes.Unimplemented, "method UploadObjects not implemented")
}
func (*UnimplementedControlPlaneServer) Metrics(srv ControlPlane_MetricsServer) error {
	return status.Errorf(codes.Unimplemented, "method Metrics not implemented")
}
func (*UnimplementedControlPlaneServer) StatusObject(ctx context.Context, req *StatusRequest) (*Status, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StatusObject not implemented")
}
func (*UnimplementedControlPlaneServer) StatusObjects(ctx context.Context, req *StatusRequestMulti) (*StatusMulti, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StatusObjects not implemented")
}

func RegisterControlPlaneServer(s *grpc.Server, srv ControlPlaneServer) {
	s.RegisterService(&_ControlPlane_serviceDesc, srv)
}

func _ControlPlane_Commands_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(ControlPlaneServer).Commands(&controlPlaneCommandsServer{stream})
}

type ControlPlane_CommandsServer interface {
	Send(*Command) error
	Recv() (*Command, error)
	grpc.ServerStream
}

type controlPlaneCommandsServer struct {
	grpc.ServerStream
}

func (x *controlPlaneCommandsServer) Send(m *Command) error {
	return x.ServerStream.SendMsg(m)
}

func (x *controlPlaneCommandsServer) Recv() (*Command, error) {
	m := new(Command)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _ControlPlane_DataChunks_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(ControlPlaneServer).DataChunks(&controlPlaneDataChunksServer{stream})
}

type ControlPlane_DataChunksServer interface {
	Send(*DataChunk) error
	Recv() (*DataChunk, error)
	grpc.ServerStream
}

type controlPlaneDataChunksServer struct {
	grpc.ServerStream
}

func (x *controlPlaneDataChunksServer) Send(m *DataChunk) error {
	return x.ServerStream.SendMsg(m)
}

func (x *controlPlaneDataChunksServer) Recv() (*DataChunk, error) {
	m := new(DataChunk)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _ControlPlane_UploadObject_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(ControlPlaneServer).UploadObject(&controlPlaneUploadObjectServer{stream})
}

type ControlPlane_UploadObjectServer interface {
	SendAndClose(*Status) error
	Recv() (*DataChunk, error)
	grpc.ServerStream
}

type controlPlaneUploadObjectServer struct {
	grpc.ServerStream
}

func (x *controlPlaneUploadObjectServer) SendAndClose(m *Status) error {
	return x.ServerStream.SendMsg(m)
}

func (x *controlPlaneUploadObjectServer) Recv() (*DataChunk, error) {
	m := new(DataChunk)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _ControlPlane_UploadObjects_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(ControlPlaneServer).UploadObjects(&controlPlaneUploadObjectsServer{stream})
}

type ControlPlane_UploadObjectsServer interface {
	SendAndClose(*StatusMulti) error
	Recv() (*DataChunk, error)
	grpc.ServerStream
}

type controlPlaneUploadObjectsServer struct {
	grpc.ServerStream
}

func (x *controlPlaneUploadObjectsServer) SendAndClose(m *StatusMulti) error {
	return x.ServerStream.SendMsg(m)
}

func (x *controlPlaneUploadObjectsServer) Recv() (*DataChunk, error) {
	m := new(DataChunk)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _ControlPlane_Metrics_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(ControlPlaneServer).Metrics(&controlPlaneMetricsServer{stream})
}

type ControlPlane_MetricsServer interface {
	SendAndClose(*Metric) error
	Recv() (*Metric, error)
	grpc.ServerStream
}

type controlPlaneMetricsServer struct {
	grpc.ServerStream
}

func (x *controlPlaneMetricsServer) SendAndClose(m *Metric) error {
	return x.ServerStream.SendMsg(m)
}

func (x *controlPlaneMetricsServer) Recv() (*Metric, error) {
	m := new(Metric)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _ControlPlane_StatusObject_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ControlPlaneServer).StatusObject(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/atlas.ControlPlane/StatusObject",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ControlPlaneServer).StatusObject(ctx, req.(*StatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ControlPlane_StatusObjects_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StatusRequestMulti)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ControlPlaneServer).StatusObjects(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/atlas.ControlPlane/StatusObjects",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ControlPlaneServer).StatusObjects(ctx, req.(*StatusRequestMulti))
	}
	return interceptor(ctx, in, info, handler)
}

var _ControlPlane_serviceDesc = grpc.ServiceDesc{
	ServiceName: "atlas.ControlPlane",
	HandlerType: (*ControlPlaneServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "StatusObject",
			Handler:    _ControlPlane_StatusObject_Handler,
		},
		{
			MethodName: "StatusObjects",
			Handler:    _ControlPlane_StatusObjects_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Commands",
			Handler:       _ControlPlane_Commands_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "DataChunks",
			Handler:       _ControlPlane_DataChunks_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "UploadObject",
			Handler:       _ControlPlane_UploadObject_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "UploadObjects",
			Handler:       _ControlPlane_UploadObjects_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "Metrics",
			Handler:       _ControlPlane_Metrics_Handler,
			ClientStreams: true,
		},
	},
	Metadata: "service_control_plane.proto",
}
