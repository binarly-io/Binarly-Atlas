// Code generated by protoc-gen-go. DO NOT EDIT.
// source: metadata.proto

package atlas

import (
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	timestamp "github.com/golang/protobuf/ptypes/timestamp"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

// Metadata describes metadata of the object
type Metadata struct {
	// Types that are valid to be assigned to TypeOptional:
	//	*Metadata_Type
	TypeOptional isMetadata_TypeOptional `protobuf_oneof:"type_optional"`
	// Types that are valid to be assigned to NameOptional:
	//	*Metadata_Name
	NameOptional isMetadata_NameOptional `protobuf_oneof:"name_optional"`
	// Types that are valid to be assigned to VersionOptional:
	//	*Metadata_Version
	VersionOptional isMetadata_VersionOptional `protobuf_oneof:"version_optional"`
	// Types that are valid to be assigned to DescriptionOptional:
	//	*Metadata_Description
	DescriptionOptional isMetadata_DescriptionOptional `protobuf_oneof:"description_optional"`
	// Types that are valid to be assigned to StatusOptional:
	//	*Metadata_Status
	StatusOptional isMetadata_StatusOptional `protobuf_oneof:"status_optional"`
	// Types that are valid to be assigned to ModeOptional:
	//	*Metadata_Mode
	ModeOptional isMetadata_ModeOptional `protobuf_oneof:"mode_optional"`
	// Types that are valid to be assigned to TsOptional:
	//	*Metadata_Ts
	TsOptional isMetadata_TsOptional `protobuf_oneof:"ts_optional"`
	// Types that are valid to be assigned to AddressesOptional:
	//	*Metadata_Addresses
	AddressesOptional isMetadata_AddressesOptional `protobuf_oneof:"addresses_optional"`
	// Types that are valid to be assigned to PresentationOptionsOptional:
	//	*Metadata_PresentationOptions
	PresentationOptionsOptional isMetadata_PresentationOptionsOptional `protobuf_oneof:"presentation_options_optional"`
	// Types that are valid to be assigned to DataChunkPropertiesOptional:
	//	*Metadata_DataChunkProperties
	DataChunkPropertiesOptional isMetadata_DataChunkPropertiesOptional `protobuf_oneof:"data_chunk_properties_optional"`
	XXX_NoUnkeyedLiteral        struct{}                               `json:"-"`
	XXX_unrecognized            []byte                                 `json:"-"`
	XXX_sizecache               int32                                  `json:"-"`
}

func (m *Metadata) Reset()      { *m = Metadata{} }
func (*Metadata) ProtoMessage() {}
func (*Metadata) Descriptor() ([]byte, []int) {
	return fileDescriptor_56d9f74966f40d04, []int{0}
}

func (m *Metadata) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Metadata.Unmarshal(m, b)
}
func (m *Metadata) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Metadata.Marshal(b, m, deterministic)
}
func (m *Metadata) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Metadata.Merge(m, src)
}
func (m *Metadata) XXX_Size() int {
	return xxx_messageInfo_Metadata.Size(m)
}
func (m *Metadata) XXX_DiscardUnknown() {
	xxx_messageInfo_Metadata.DiscardUnknown(m)
}

var xxx_messageInfo_Metadata proto.InternalMessageInfo

type isMetadata_TypeOptional interface {
	isMetadata_TypeOptional()
}

type Metadata_Type struct {
	Type int32 `protobuf:"varint,100,opt,name=type,proto3,oneof"`
}

func (*Metadata_Type) isMetadata_TypeOptional() {}

func (m *Metadata) GetTypeOptional() isMetadata_TypeOptional {
	if m != nil {
		return m.TypeOptional
	}
	return nil
}

func (m *Metadata) GetType() int32 {
	if x, ok := m.GetTypeOptional().(*Metadata_Type); ok {
		return x.Type
	}
	return 0
}

type isMetadata_NameOptional interface {
	isMetadata_NameOptional()
}

type Metadata_Name struct {
	Name string `protobuf:"bytes,200,opt,name=name,proto3,oneof"`
}

func (*Metadata_Name) isMetadata_NameOptional() {}

func (m *Metadata) GetNameOptional() isMetadata_NameOptional {
	if m != nil {
		return m.NameOptional
	}
	return nil
}

func (m *Metadata) GetName() string {
	if x, ok := m.GetNameOptional().(*Metadata_Name); ok {
		return x.Name
	}
	return ""
}

type isMetadata_VersionOptional interface {
	isMetadata_VersionOptional()
}

type Metadata_Version struct {
	Version int32 `protobuf:"varint,300,opt,name=version,proto3,oneof"`
}

func (*Metadata_Version) isMetadata_VersionOptional() {}

func (m *Metadata) GetVersionOptional() isMetadata_VersionOptional {
	if m != nil {
		return m.VersionOptional
	}
	return nil
}

func (m *Metadata) GetVersion() int32 {
	if x, ok := m.GetVersionOptional().(*Metadata_Version); ok {
		return x.Version
	}
	return 0
}

type isMetadata_DescriptionOptional interface {
	isMetadata_DescriptionOptional()
}

type Metadata_Description struct {
	Description string `protobuf:"bytes,400,opt,name=description,proto3,oneof"`
}

func (*Metadata_Description) isMetadata_DescriptionOptional() {}

func (m *Metadata) GetDescriptionOptional() isMetadata_DescriptionOptional {
	if m != nil {
		return m.DescriptionOptional
	}
	return nil
}

func (m *Metadata) GetDescription() string {
	if x, ok := m.GetDescriptionOptional().(*Metadata_Description); ok {
		return x.Description
	}
	return ""
}

type isMetadata_StatusOptional interface {
	isMetadata_StatusOptional()
}

type Metadata_Status struct {
	Status int32 `protobuf:"varint,500,opt,name=status,proto3,oneof"`
}

func (*Metadata_Status) isMetadata_StatusOptional() {}

func (m *Metadata) GetStatusOptional() isMetadata_StatusOptional {
	if m != nil {
		return m.StatusOptional
	}
	return nil
}

func (m *Metadata) GetStatus() int32 {
	if x, ok := m.GetStatusOptional().(*Metadata_Status); ok {
		return x.Status
	}
	return 0
}

type isMetadata_ModeOptional interface {
	isMetadata_ModeOptional()
}

type Metadata_Mode struct {
	Mode int32 `protobuf:"varint,600,opt,name=mode,proto3,oneof"`
}

func (*Metadata_Mode) isMetadata_ModeOptional() {}

func (m *Metadata) GetModeOptional() isMetadata_ModeOptional {
	if m != nil {
		return m.ModeOptional
	}
	return nil
}

func (m *Metadata) GetMode() int32 {
	if x, ok := m.GetModeOptional().(*Metadata_Mode); ok {
		return x.Mode
	}
	return 0
}

type isMetadata_TsOptional interface {
	isMetadata_TsOptional()
}

type Metadata_Ts struct {
	Ts *timestamp.Timestamp `protobuf:"bytes,700,opt,name=ts,proto3,oneof"`
}

func (*Metadata_Ts) isMetadata_TsOptional() {}

func (m *Metadata) GetTsOptional() isMetadata_TsOptional {
	if m != nil {
		return m.TsOptional
	}
	return nil
}

func (m *Metadata) GetTs() *timestamp.Timestamp {
	if x, ok := m.GetTsOptional().(*Metadata_Ts); ok {
		return x.Ts
	}
	return nil
}

type isMetadata_AddressesOptional interface {
	isMetadata_AddressesOptional()
}

type Metadata_Addresses struct {
	Addresses *AddressMap `protobuf:"bytes,800,opt,name=addresses,proto3,oneof"`
}

func (*Metadata_Addresses) isMetadata_AddressesOptional() {}

func (m *Metadata) GetAddressesOptional() isMetadata_AddressesOptional {
	if m != nil {
		return m.AddressesOptional
	}
	return nil
}

func (m *Metadata) GetAddresses() *AddressMap {
	if x, ok := m.GetAddressesOptional().(*Metadata_Addresses); ok {
		return x.Addresses
	}
	return nil
}

type isMetadata_PresentationOptionsOptional interface {
	isMetadata_PresentationOptionsOptional()
}

type Metadata_PresentationOptions struct {
	PresentationOptions *PresentationOptions `protobuf:"bytes,900,opt,name=presentation_options,json=presentationOptions,proto3,oneof"`
}

func (*Metadata_PresentationOptions) isMetadata_PresentationOptionsOptional() {}

func (m *Metadata) GetPresentationOptionsOptional() isMetadata_PresentationOptionsOptional {
	if m != nil {
		return m.PresentationOptionsOptional
	}
	return nil
}

func (m *Metadata) GetPresentationOptions() *PresentationOptions {
	if x, ok := m.GetPresentationOptionsOptional().(*Metadata_PresentationOptions); ok {
		return x.PresentationOptions
	}
	return nil
}

type isMetadata_DataChunkPropertiesOptional interface {
	isMetadata_DataChunkPropertiesOptional()
}

type Metadata_DataChunkProperties struct {
	DataChunkProperties *DataChunkProperties `protobuf:"bytes,1000,opt,name=data_chunk_properties,json=dataChunkProperties,proto3,oneof"`
}

func (*Metadata_DataChunkProperties) isMetadata_DataChunkPropertiesOptional() {}

func (m *Metadata) GetDataChunkPropertiesOptional() isMetadata_DataChunkPropertiesOptional {
	if m != nil {
		return m.DataChunkPropertiesOptional
	}
	return nil
}

func (m *Metadata) GetDataChunkProperties() *DataChunkProperties {
	if x, ok := m.GetDataChunkPropertiesOptional().(*Metadata_DataChunkProperties); ok {
		return x.DataChunkProperties
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*Metadata) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*Metadata_Type)(nil),
		(*Metadata_Name)(nil),
		(*Metadata_Version)(nil),
		(*Metadata_Description)(nil),
		(*Metadata_Status)(nil),
		(*Metadata_Mode)(nil),
		(*Metadata_Ts)(nil),
		(*Metadata_Addresses)(nil),
		(*Metadata_PresentationOptions)(nil),
		(*Metadata_DataChunkProperties)(nil),
	}
}

func init() {
	proto.RegisterType((*Metadata)(nil), "atlas.Metadata")
}

func init() { proto.RegisterFile("metadata.proto", fileDescriptor_56d9f74966f40d04) }

var fileDescriptor_56d9f74966f40d04 = []byte{
	// 423 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x6c, 0x91, 0x4f, 0x6e, 0xd4, 0x30,
	0x14, 0x87, 0x49, 0x26, 0xc9, 0x74, 0xde, 0xa8, 0x94, 0x71, 0x53, 0x64, 0x52, 0x41, 0x23, 0xd8,
	0xcc, 0x86, 0x54, 0x2a, 0x27, 0xe0, 0xcf, 0x22, 0x9b, 0x8a, 0xc1, 0x62, 0x1f, 0xb9, 0x8d, 0x29,
	0x11, 0x93, 0xd8, 0x8a, 0xdf, 0x20, 0xb1, 0x67, 0x8b, 0xc4, 0x11, 0x38, 0x00, 0x47, 0xe0, 0x00,
	0x1c, 0x81, 0x23, 0x70, 0x00, 0x0e, 0x80, 0xec, 0x38, 0x93, 0x54, 0xcd, 0x2a, 0xf2, 0xf7, 0x7e,
	0xef, 0xbd, 0xe8, 0x7b, 0x70, 0xbf, 0x16, 0xc8, 0x4b, 0x8e, 0x3c, 0x53, 0xad, 0x44, 0x49, 0x42,
	0x8e, 0x5b, 0xae, 0x93, 0xb3, 0x1b, 0x29, 0x6f, 0xb6, 0xe2, 0xdc, 0xc2, 0xab, 0xdd, 0x87, 0x73,
	0xac, 0x6a, 0xa1, 0x91, 0xd7, 0xaa, 0xcb, 0x25, 0x2b, 0x5e, 0x96, 0xad, 0xd0, 0xba, 0xa8, 0x79,
	0x8f, 0x4e, 0xcd, 0x98, 0xe2, 0xfa, 0xe3, 0xae, 0xf9, 0x54, 0xa8, 0x56, 0x2a, 0xd1, 0x62, 0x25,
	0xb4, 0x2b, 0x26, 0xaa, 0x15, 0x5a, 0x34, 0xc8, 0xb1, 0x92, 0x4d, 0x21, 0x95, 0xf9, 0xb8, 0xda,
	0xd3, 0x6f, 0x21, 0x1c, 0x5c, 0xba, 0xdf, 0x20, 0x31, 0x04, 0xf8, 0x45, 0x09, 0x5a, 0xa6, 0xde,
	0x3a, 0xcc, 0xef, 0x31, 0xfb, 0x22, 0x27, 0x10, 0x34, 0xbc, 0x16, 0xf4, 0xb7, 0x97, 0x7a, 0xeb,
	0x45, 0xee, 0x31, 0xfb, 0x24, 0xa7, 0x30, 0xff, 0x2c, 0x5a, 0x5d, 0xc9, 0x86, 0xfe, 0xf4, 0x6d,
	0x83, 0xcf, 0x7a, 0x42, 0x9e, 0xc1, 0xb2, 0x14, 0xfa, 0xba, 0xad, 0xec, 0x32, 0xfa, 0x7d, 0x66,
	0x5b, 0x67, 0x6c, 0x4c, 0xc9, 0x23, 0x88, 0x34, 0x72, 0xdc, 0x69, 0xfa, 0x6f, 0x66, 0x07, 0x04,
	0xcc, 0x01, 0xb3, 0xb3, 0x96, 0xa5, 0xa0, 0x7f, 0x02, 0x5b, 0x08, 0x99, 0x7d, 0x92, 0xe7, 0xe0,
	0xa3, 0xa6, 0xbf, 0xc2, 0xd4, 0x5b, 0x2f, 0x2f, 0x92, 0xac, 0x13, 0x95, 0xf5, 0xa2, 0xb2, 0xf7,
	0xbd, 0xa8, 0x3c, 0x62, 0x3e, 0x6a, 0x72, 0x01, 0x0b, 0xa7, 0x4a, 0x68, 0xfa, 0x23, 0xb2, 0x5d,
	0xab, 0xcc, 0x5a, 0xce, 0x5e, 0x76, 0x85, 0x4b, 0xae, 0xf2, 0x39, 0x1b, 0x62, 0x64, 0x03, 0xf1,
	0x94, 0x2e, 0xfa, 0x75, 0xee, 0x96, 0x76, 0xed, 0x9b, 0x51, 0xe6, 0x6d, 0x17, 0xc9, 0x0f, 0xd8,
	0xb1, 0xba, 0x8b, 0xc9, 0x3b, 0x38, 0x99, 0xbc, 0x0e, 0xfd, 0x7b, 0x7b, 0xe4, 0x1b, 0x8e, 0xfc,
	0xb5, 0xc9, 0x6c, 0xf6, 0x91, 0x7c, 0xc1, 0x8e, 0xcb, 0xbb, 0xf8, 0xd5, 0x11, 0x1c, 0x9a, 0xd3,
	0xb8, 0x9f, 0xe3, 0x5b, 0x03, 0xcc, 0x51, 0x06, 0x40, 0xe0, 0x81, 0xbb, 0xc5, 0xc0, 0x1e, 0x42,
	0x3c, 0xd2, 0x3f, 0xf0, 0x15, 0x1c, 0x75, 0xda, 0x6f, 0xcd, 0x33, 0xc2, 0x07, 0x70, 0x08, 0x4b,
	0x1c, 0xd5, 0x63, 0x20, 0x7b, 0x65, 0x03, 0x3d, 0x83, 0xc7, 0x53, 0xee, 0x86, 0x40, 0x0a, 0x4f,
	0x26, 0x55, 0xec, 0x13, 0x57, 0x91, 0x3d, 0xe6, 0x8b, 0xff, 0x01, 0x00, 0x00, 0xff, 0xff, 0xeb,
	0x15, 0xf5, 0xfe, 0x1c, 0x03, 0x00, 0x00,
}
