// Code generated by protoc-gen-go. DO NOT EDIT.
// source: service_mservice.proto

package mservice

import (
	context "context"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

func init() {
	proto.RegisterFile("service_mservice.proto", fileDescriptor_80e18350aa7dc762)
}

var fileDescriptor_80e18350aa7dc762 = []byte{
	// 172 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xe2, 0x12, 0x2b, 0x4e, 0x2d, 0x2a,
	0xcb, 0x4c, 0x4e, 0x8d, 0xcf, 0x85, 0x32, 0xf4, 0x0a, 0x8a, 0xf2, 0x4b, 0xf2, 0x85, 0x38, 0x60,
	0x7c, 0x29, 0xa1, 0x92, 0xca, 0x82, 0xd4, 0xf8, 0xe4, 0xfc, 0xdc, 0xdc, 0xc4, 0xbc, 0x14, 0x88,
	0xac, 0x94, 0x28, 0x58, 0x2c, 0x25, 0xb1, 0x24, 0x31, 0x3e, 0x39, 0xa3, 0x34, 0x2f, 0x1b, 0x2a,
	0x2c, 0x08, 0x16, 0xce, 0x4d, 0x2d, 0x29, 0xca, 0x4c, 0x86, 0x08, 0x19, 0xad, 0x61, 0xe4, 0xe2,
	0xf0, 0x0d, 0x86, 0x18, 0x25, 0x64, 0xca, 0xc5, 0xee, 0x9c, 0x9f, 0x57, 0x52, 0x94, 0x9f, 0x23,
	0x24, 0xa8, 0x07, 0xb7, 0xd0, 0x19, 0x62, 0xb4, 0x14, 0xa6, 0x90, 0x12, 0x83, 0x06, 0xa3, 0x01,
	0xa3, 0x90, 0x19, 0x17, 0x8b, 0x4b, 0x62, 0x49, 0xa2, 0x90, 0x30, 0x42, 0x01, 0x88, 0xef, 0x0c,
	0xb2, 0x59, 0x0a, 0x9b, 0x20, 0x54, 0x9f, 0x21, 0x17, 0xbb, 0x2f, 0xd8, 0x2d, 0xc5, 0x42, 0x02,
	0x08, 0x55, 0x10, 0x21, 0x29, 0x0c, 0x11, 0x90, 0xa6, 0x24, 0x36, 0xb0, 0xab, 0x8d, 0x01, 0x01,
	0x00, 0x00, 0xff, 0xff, 0x52, 0x4f, 0x9c, 0xc3, 0x17, 0x01, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConnInterface

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion6

// MServiceClient is the client API for MService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type MServiceClient interface {
	// Bi-directional Commands stream
	//
	// Commands are sent from service to client and from client to server
	Control(ctx context.Context, opts ...grpc.CallOption) (MService_ControlClient, error)
	// Bi-directional Data stream
	//
	// Some commands can followed by data load. Be it logs, dumps, etc.
	Data(ctx context.Context, opts ...grpc.CallOption) (MService_DataClient, error)
	// Metrics stream
	//
	// Some commands can be followed by metrics stream.
	Metrics(ctx context.Context, opts ...grpc.CallOption) (MService_MetricsClient, error)
}

type mServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewMServiceClient(cc grpc.ClientConnInterface) MServiceClient {
	return &mServiceClient{cc}
}

func (c *mServiceClient) Control(ctx context.Context, opts ...grpc.CallOption) (MService_ControlClient, error) {
	stream, err := c.cc.NewStream(ctx, &_MService_serviceDesc.Streams[0], "/mservice.MService/Control", opts...)
	if err != nil {
		return nil, err
	}
	x := &mServiceControlClient{stream}
	return x, nil
}

type MService_ControlClient interface {
	Send(*Command) error
	Recv() (*Command, error)
	grpc.ClientStream
}

type mServiceControlClient struct {
	grpc.ClientStream
}

func (x *mServiceControlClient) Send(m *Command) error {
	return x.ClientStream.SendMsg(m)
}

func (x *mServiceControlClient) Recv() (*Command, error) {
	m := new(Command)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *mServiceClient) Data(ctx context.Context, opts ...grpc.CallOption) (MService_DataClient, error) {
	stream, err := c.cc.NewStream(ctx, &_MService_serviceDesc.Streams[1], "/mservice.MService/Data", opts...)
	if err != nil {
		return nil, err
	}
	x := &mServiceDataClient{stream}
	return x, nil
}

type MService_DataClient interface {
	Send(*DataChunk) error
	Recv() (*DataChunk, error)
	grpc.ClientStream
}

type mServiceDataClient struct {
	grpc.ClientStream
}

func (x *mServiceDataClient) Send(m *DataChunk) error {
	return x.ClientStream.SendMsg(m)
}

func (x *mServiceDataClient) Recv() (*DataChunk, error) {
	m := new(DataChunk)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *mServiceClient) Metrics(ctx context.Context, opts ...grpc.CallOption) (MService_MetricsClient, error) {
	stream, err := c.cc.NewStream(ctx, &_MService_serviceDesc.Streams[2], "/mservice.MService/Metrics", opts...)
	if err != nil {
		return nil, err
	}
	x := &mServiceMetricsClient{stream}
	return x, nil
}

type MService_MetricsClient interface {
	Send(*Metric) error
	CloseAndRecv() (*Metric, error)
	grpc.ClientStream
}

type mServiceMetricsClient struct {
	grpc.ClientStream
}

func (x *mServiceMetricsClient) Send(m *Metric) error {
	return x.ClientStream.SendMsg(m)
}

func (x *mServiceMetricsClient) CloseAndRecv() (*Metric, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(Metric)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// MServiceServer is the server API for MService service.
type MServiceServer interface {
	// Bi-directional Commands stream
	//
	// Commands are sent from service to client and from client to server
	Control(MService_ControlServer) error
	// Bi-directional Data stream
	//
	// Some commands can followed by data load. Be it logs, dumps, etc.
	Data(MService_DataServer) error
	// Metrics stream
	//
	// Some commands can be followed by metrics stream.
	Metrics(MService_MetricsServer) error
}

// UnimplementedMServiceServer can be embedded to have forward compatible implementations.
type UnimplementedMServiceServer struct {
}

func (*UnimplementedMServiceServer) Control(srv MService_ControlServer) error {
	return status.Errorf(codes.Unimplemented, "method Control not implemented")
}
func (*UnimplementedMServiceServer) Data(srv MService_DataServer) error {
	return status.Errorf(codes.Unimplemented, "method Data not implemented")
}
func (*UnimplementedMServiceServer) Metrics(srv MService_MetricsServer) error {
	return status.Errorf(codes.Unimplemented, "method Metrics not implemented")
}

func RegisterMServiceServer(s *grpc.Server, srv MServiceServer) {
	s.RegisterService(&_MService_serviceDesc, srv)
}

func _MService_Control_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(MServiceServer).Control(&mServiceControlServer{stream})
}

type MService_ControlServer interface {
	Send(*Command) error
	Recv() (*Command, error)
	grpc.ServerStream
}

type mServiceControlServer struct {
	grpc.ServerStream
}

func (x *mServiceControlServer) Send(m *Command) error {
	return x.ServerStream.SendMsg(m)
}

func (x *mServiceControlServer) Recv() (*Command, error) {
	m := new(Command)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _MService_Data_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(MServiceServer).Data(&mServiceDataServer{stream})
}

type MService_DataServer interface {
	Send(*DataChunk) error
	Recv() (*DataChunk, error)
	grpc.ServerStream
}

type mServiceDataServer struct {
	grpc.ServerStream
}

func (x *mServiceDataServer) Send(m *DataChunk) error {
	return x.ServerStream.SendMsg(m)
}

func (x *mServiceDataServer) Recv() (*DataChunk, error) {
	m := new(DataChunk)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _MService_Metrics_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(MServiceServer).Metrics(&mServiceMetricsServer{stream})
}

type MService_MetricsServer interface {
	SendAndClose(*Metric) error
	Recv() (*Metric, error)
	grpc.ServerStream
}

type mServiceMetricsServer struct {
	grpc.ServerStream
}

func (x *mServiceMetricsServer) SendAndClose(m *Metric) error {
	return x.ServerStream.SendMsg(m)
}

func (x *mServiceMetricsServer) Recv() (*Metric, error) {
	m := new(Metric)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _MService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "mservice.MService",
	HandlerType: (*MServiceServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Control",
			Handler:       _MService_Control_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "Data",
			Handler:       _MService_Data_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "Metrics",
			Handler:       _MService_Metrics_Handler,
			ClientStreams: true,
		},
	},
	Metadata: "service_mservice.proto",
}
